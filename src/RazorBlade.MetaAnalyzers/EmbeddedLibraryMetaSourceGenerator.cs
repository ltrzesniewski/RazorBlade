using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;
using RazorBlade.Analyzers.Support;
using RazorBlade.MetaAnalyzers.Support;

namespace RazorBlade.MetaAnalyzers;

[Generator]
public sealed class EmbeddedLibraryMetaSourceGenerator : IIncrementalGenerator
{
    private static readonly Regex _newlineRegex = new(@"\r?\n", RegexOptions.Compiled);
    private static readonly Regex _doubleQuotesRegex = new(@"""+", RegexOptions.Compiled);

    internal bool SkipGlobal { get; init; }

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var inputFiles = context.AdditionalTextsProvider
                                .Where(static i => i.Path.EndsWith(".cs", StringComparison.OrdinalIgnoreCase))
                                .Combine(context.AnalyzerConfigOptionsProvider)
                                .Select(static (pair, _) => GetInputFile(pair.Left, pair.Right))
                                .WhereNotNull();

        var memberNames = inputFiles.Select(static (i, _) => i.GetMemberName())
                                    .Collect();

        context.RegisterImplementationSourceOutput(inputFiles, GenerateContent);

        if (!SkipGlobal)
            context.RegisterSourceOutput(memberNames, GenerateGlobal);
    }

    private static InputFile? GetInputFile(AdditionalText additionalText, AnalyzerConfigOptionsProvider analyzerConfigOptions)
    {
        var options = analyzerConfigOptions.GetOptions(additionalText);

        if (!options.TryGetValue("build_metadata.AdditionalFiles.Role", out var role) || !string.Equals(role, "Library", StringComparison.OrdinalIgnoreCase))
            return null;

        return new InputFile(additionalText);
    }

    private static void GenerateContent(SourceProductionContext context, InputFile inputFile)
    {
        var sourceText = inputFile.AdditionalText.GetText(context.CancellationToken);
        if (sourceText is null)
            return;

        var inputText = TransformSource(sourceText.ToString(), context.CancellationToken);
        var memberName = inputFile.GetMemberName();

        var writer = new SourceWriter();
        WriteHeader(writer);

        using (writer.BlockScope())
        {
            var escapeQuotes = GetRawStringLiteralQuotes(inputText);

            writer.WriteLine("//language=csharp");
            writer.WriteLine($"private static string {memberName} => {escapeQuotes}");
            using (writer.IndentScope())
            {
                foreach (var line in _newlineRegex.Split(inputText))
                    writer.WriteLine(line);

                writer.WriteLine($"{escapeQuotes};");
            }
        }

        context.AddSource($"{memberName}.g.cs", writer.ToString());
    }

    private static void GenerateGlobal(SourceProductionContext context, ImmutableArray<string> memberNames)
    {
        var writer = new SourceWriter();
        WriteHeader(writer);

        using (writer.BlockScope())
        {
            writer.WriteLine("public static readonly File[] Files = [");

            using (writer.IndentScope())
            {
                foreach (var memberName in memberNames.OrderBy(i => i, StringComparer.OrdinalIgnoreCase))
                    writer.WriteLine($"""new("{memberName}", {memberName}),""");
            }

            writer.WriteLine("];");
            writer.WriteLine();
            writer.WriteLine("public readonly record struct File(string Name, string Source);");
        }

        context.AddSource("Files.g.cs", writer.ToString());
    }

    private static void WriteHeader(SourceWriter writer)
    {
        writer.WriteLine("// <auto-generated />");
        writer.WriteLine();
        writer.WriteLine("namespace RazorBlade.Analyzers;");
        writer.WriteLine();
        writer.WriteLine("internal static partial class EmbeddedLibrary");
    }

    private static string TransformSource([StringSyntax("csharp")] string sourceText, CancellationToken cancellationToken)
    {
        // - Add header comment
        // - Add #nullable enable
        // - Make public top-level types internal
        // - Make protected internal members protected

        // language=csharp
        sourceText = $"""
            // This file is part of the RazorBlade library.

            #nullable enable

            {sourceText}
            """;

        var syntaxTree = CSharpSyntaxTree.ParseText(sourceText, CSharpParseOptions.Default, cancellationToken: cancellationToken);
        var root = syntaxTree.GetRoot(cancellationToken);

        root = new AccessibilityLevelRewriter().Visit(root);

        return root.ToFullString();
    }

    private static string GetRawStringLiteralQuotes(string value)
    {
        var escapeQuotesLength = 3;
        foreach (Match match in _doubleQuotesRegex.Matches(value))
            escapeQuotesLength = Math.Max(escapeQuotesLength, match.Length + 1);

        return new string('"', escapeQuotesLength);
    }

    private record InputFile(AdditionalText AdditionalText)
    {
        public string GetMemberName()
            => Path.GetFileNameWithoutExtension(AdditionalText.Path);
    }

    private sealed class AccessibilityLevelRewriter : CSharpSyntaxWalker
    {
        private readonly HashSet<SyntaxToken> _toReplace = [];
        private bool _isTopLevel;

        public new SyntaxNode Visit(SyntaxNode root)
        {
            _toReplace.Clear();
            _isTopLevel = true;

            base.Visit(root);

            return root.ReplaceTokens(
                _toReplace,
                static (token, _) => token.Kind() switch
                {
                    SyntaxKind.PublicKeyword   => SyntaxFactory.Token(SyntaxKind.InternalKeyword).WithTriviaFrom(token),
                    SyntaxKind.InternalKeyword => default,
                    _                          => throw new InvalidOperationException("Unexpected token type")
                }
            );
        }

        public override void DefaultVisit(SyntaxNode node)
        {
            if (node is MemberDeclarationSyntax member)
            {
                HandleMember(member);

                if (_isTopLevel && node is BaseTypeDeclarationSyntax)
                {
                    _isTopLevel = false;
                    base.DefaultVisit(node);
                    _isTopLevel = true;
                    return;
                }
            }

            base.DefaultVisit(node);
        }

        private void HandleMember(MemberDeclarationSyntax node)
        {
            var hasProtected = false;
            HandleModifiers(node.Modifiers, ref hasProtected);

            if (hasProtected && node is PropertyDeclarationSyntax { AccessorList: { } accessorList })
            {
                foreach (var accessor in accessorList.Accessors)
                    HandleModifiers(accessor.Modifiers, ref hasProtected);
            }
        }

        private void HandleModifiers(SyntaxTokenList modifiers, ref bool hasProtected)
        {
            foreach (var modifier in modifiers)
            {
                switch (modifier.Kind())
                {
                    case SyntaxKind.PublicKeyword:
                        if (_isTopLevel)
                            _toReplace.Add(modifier);
                        break;

                    case SyntaxKind.ProtectedKeyword:
                        hasProtected = true;
                        break;

                    case SyntaxKind.InternalKeyword:
                        if (hasProtected)
                            _toReplace.Add(modifier);
                        break;
                }
            }
        }
    }
}
