using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading;
using JetBrains.Annotations;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;
using RazorBlade.Analyzers.Support;
using RazorBlade.MetaAnalyzers.Support;

namespace RazorBlade.MetaAnalyzers;

[Generator]
public class EmbeddedLibraryMetaSourceGenerator : IIncrementalGenerator
{
    private static readonly Regex _newlineRegex = new(@"\r?\n", RegexOptions.Compiled);
    private static readonly Regex _doubleQuotesRegex = new(@"""+", RegexOptions.Compiled);

    internal bool SkipAddSource { get; init; }

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var inputFiles = context.AdditionalTextsProvider
                                .Where(static i => i.Path.EndsWith(".cs", StringComparison.OrdinalIgnoreCase))
                                .Combine(context.AnalyzerConfigOptionsProvider)
                                .Select(static (pair, _) => GetInputFile(pair.Left, pair.Right))
                                .WhereNotNull();

        var memberNames = inputFiles.Select(static (i, _) => i.GetMemberName())
                                    .Collect();

        context.RegisterImplementationSourceOutput(inputFiles, GenerateContent);

        if (!SkipAddSource)
            context.RegisterSourceOutput(memberNames, GenerateAddSource);
    }

    private static InputFile? GetInputFile(AdditionalText additionalText, AnalyzerConfigOptionsProvider analyzerConfigOptions)
    {
        var options = analyzerConfigOptions.GetOptions(additionalText);

        if (!options.TryGetValue("build_metadata.AdditionalFiles.Role", out var role) || !string.Equals(role, "Library", StringComparison.OrdinalIgnoreCase))
            return null;

        return new InputFile(additionalText);
    }

    private static void GenerateContent(SourceProductionContext context, InputFile inputFile)
    {
        var sourceText = inputFile.AdditionalText.GetText(context.CancellationToken);
        if (sourceText is null)
            return;

        var inputText = TransformSource(sourceText.ToString(), context.CancellationToken);
        var memberName = inputFile.GetMemberName();

        var writer = new SourceWriter();
        WriteHeader(writer);

        using (writer.BlockScope())
        {
            var escapeQuotes = GetRawStringLiteralQuotes(inputText);

            writer.WriteLine("//language=csharp");
            writer.WriteLine($"private static string {memberName} => {escapeQuotes}");
            using (writer.IndentScope())
            {
                foreach (var line in _newlineRegex.Split(inputText))
                    writer.WriteLine(line);

                writer.WriteLine($"{escapeQuotes};");
            }
        }

        context.AddSource($"{memberName}.g.cs", writer.ToString());
    }

    private static void GenerateAddSource(SourceProductionContext context, ImmutableArray<string> memberNames)
    {
        var writer = new SourceWriter();
        WriteHeader(writer);

        using (writer.BlockScope())
        {
            writer.WriteLine("public static void AddSource(Microsoft.CodeAnalysis.SourceProductionContext context)");

            using (writer.BlockScope())
            {
                foreach (var memberName in memberNames.OrderBy(i => i, StringComparer.OrdinalIgnoreCase))
                    writer.WriteLine($"""context.AddSource("{memberName}.g.cs", {memberName});""");
            }
        }

        context.AddSource("AddSource.g.cs", writer.ToString());
    }

    private static void WriteHeader(SourceWriter writer)
    {
        writer.WriteLine("// <auto-generated />");
        writer.WriteLine();
        writer.WriteLine("namespace RazorBlade.Analyzers;");
        writer.WriteLine();
        writer.WriteLine("internal static partial class EmbeddedLibrary");
    }

    private static string TransformSource([LanguageInjection("csharp")] string sourceText, CancellationToken cancellationToken)
    {
        // - Add header comment
        // - Add #nullable enable
        // - Make public top-level types internal
        // - Make protected internal members protected
        // - Remove JetBrains annotations

        sourceText = $"""
            // This file is part of the RazorBlade library.

            #nullable enable

            {sourceText}
            """;

        var syntaxTree = CSharpSyntaxTree.ParseText(sourceText, CSharpParseOptions.Default, cancellationToken: cancellationToken);
        var root = syntaxTree.GetRoot(cancellationToken);

        root = new AccessibilityLevelRewriter().Visit(root);
        root = new RemoveJetBrainsAnnotationsRewriter().Visit(root);

        return root.ToFullString();
    }

    private static string GetRawStringLiteralQuotes(string value)
    {
        var escapeQuotesLength = 3;
        foreach (Match match in _doubleQuotesRegex.Matches(value))
            escapeQuotesLength = Math.Max(escapeQuotesLength, match.Length + 1);

        return new string('"', escapeQuotesLength);
    }

    private record InputFile(AdditionalText AdditionalText)
    {
        public string GetMemberName()
            => Path.GetFileNameWithoutExtension(AdditionalText.Path);
    }

    private class AccessibilityLevelRewriter : CSharpSyntaxWalker
    {
        private readonly HashSet<SyntaxToken> _toReplace = new();
        private bool _isTopLevel;

        public new SyntaxNode Visit(SyntaxNode root)
        {
            _toReplace.Clear();
            _isTopLevel = true;

            base.Visit(root);

            return root.ReplaceTokens(
                _toReplace,
                static (token, _) => token.Kind() switch
                {
                    SyntaxKind.PublicKeyword   => SyntaxFactory.Token(SyntaxKind.InternalKeyword).WithTriviaFrom(token),
                    SyntaxKind.InternalKeyword => default,
                    _                          => throw new InvalidOperationException("Unexpected token type")
                }
            );
        }

        public override void DefaultVisit(SyntaxNode node)
        {
            if (node is MemberDeclarationSyntax member)
            {
                HandleMember(member);

                if (_isTopLevel && node is BaseTypeDeclarationSyntax)
                {
                    _isTopLevel = false;
                    base.DefaultVisit(node);
                    _isTopLevel = true;
                    return;
                }
            }

            base.DefaultVisit(node);
        }

        private void HandleMember(MemberDeclarationSyntax node)
        {
            var hasProtected = false;
            HandleModifiers(node.Modifiers, ref hasProtected);

            if (hasProtected && node is PropertyDeclarationSyntax { AccessorList: { } accessorList })
            {
                foreach (var accessor in accessorList.Accessors)
                    HandleModifiers(accessor.Modifiers, ref hasProtected);
            }
        }

        private void HandleModifiers(SyntaxTokenList modifiers, ref bool hasProtected)
        {
            foreach (var modifier in modifiers)
            {
                switch (modifier.Kind())
                {
                    case SyntaxKind.PublicKeyword:
                        if (_isTopLevel)
                            _toReplace.Add(modifier);
                        break;

                    case SyntaxKind.ProtectedKeyword:
                        hasProtected = true;
                        break;

                    case SyntaxKind.InternalKeyword:
                        if (hasProtected)
                            _toReplace.Add(modifier);
                        break;
                }
            }
        }
    }

    private class RemoveJetBrainsAnnotationsRewriter : CSharpSyntaxRewriter
    {
        private static readonly HashSet<string> _attributes = new()
        {
            "CanBeNull", "NotNull", "ItemNotNull", "ItemCanBeNull", "StringFormatMethod", "StructuredMessageTemplate", "ValueProvider", "ValueRange",
            "NonNegativeValue", "InvokerParameterName", "NotifyPropertyChangedInvocator", "ContractAnnotation", "LocalizationRequired",
            "CannotApplyEqualityOperator", "Component", "BaseTypeRequired", "UsedImplicitly", "MeansImplicitUse", "PublicAPI", "InstantHandle",
            "MustUseReturnValue", "RequireStaticDelegate", "ProvidesContext", "PathReference", "SourceTemplate", "Macro", "CollectionAccess", "AssertionMethod",
            "AssertionCondition", "TerminatesProgram", "LinqTunnel", "NoEnumeration", "RegexPattern", "LanguageInjection", "NoReorder", "CodeTemplate",
            "AspChildControlType", "AspDataField", "AspDataFields", "AspMethodProperty", "AspRequiredAttribute", "AspTypeProperty", "AspMvcAreaMasterLocationFormat",
            "AspMvcAreaPartialViewLocationFormat", "AspMvcAreaViewLocationFormat", "AspMvcMasterLocationFormat", "AspMvcPartialViewLocationFormat",
            "AspMvcViewLocationFormat", "AspMvcAction", "AspMvcArea", "AspMvcController", "AspMvcMaster", "AspMvcModelType", "AspMvcPartialView",
            "AspMvcSuppressViewError", "AspMvcDisplayTemplate", "AspMvcEditorTemplate", "AspMvcTemplate", "AspMvcView", "AspMvcViewComponent",
            "AspMvcViewComponentView", "AspMvcActionSelector", "RouteTemplate", "RouteParameterConstraint", "UriString", "AspRouteConvention",
            "AspDefaultRouteValues", "AspRouteValuesConstraints", "AspRouteOrder", "AspRouteVerbs", "AspAttributeRouting", "AspMinimalApiDeclaration",
            "AspMinimalApiHandler", "HtmlElementAttributes", "HtmlAttributeValue", "RazorSection", "RazorImportNamespace", "RazorInjection",
            "RazorDirective", "RazorPageBaseType", "RazorHelperCommon", "RazorLayout", "RazorWriteLiteralMethod", "RazorWriteMethod", "RazorWriteMethodParameter",
            "XamlItemsControl", "XamlItemBindingOfItemsControl", "XamlItemStyleOfItemsControl", "XamlOneWayBindingModeByDefault", "XamlTwoWayBindingModeByDefault"

            // "Pure" can be confused with System.Diagnostics.Contracts.PureAttribute, so we don't remove it.
        };

        private SyntaxTriviaList _pendingLeadingTrivia = SyntaxTriviaList.Empty;

        public override SyntaxNode? VisitUsingDirective(UsingDirectiveSyntax node)
        {
            if (node.Name.ToString() == "JetBrains.Annotations")
                return null;

            return node;
        }

        public override SyntaxNode? VisitAttribute(AttributeSyntax node)
        {
            if (_attributes.Contains(node.Name.ToString()))
                return null;

            return node;
        }

        public override SyntaxNode? VisitAttributeList(AttributeListSyntax node)
        {
            node = node.WithOpenBracketToken(VisitToken(node.OpenBracketToken));

            var newAttributes = node.Attributes;

            for (var i = node.Attributes.Count - 1; i >= 0; i--)
            {
                if (VisitListElement(node.Attributes[i]) is null)
                    newAttributes = newAttributes.RemoveAt(i);
            }

            if (newAttributes.Count != 0)
                return node.WithAttributes(newAttributes);

            _pendingLeadingTrivia = node.GetLeadingTrivia();
            return null;
        }

        public override SyntaxToken VisitToken(SyntaxToken token)
        {
            if (_pendingLeadingTrivia.Any())
            {
                var trivia = _pendingLeadingTrivia;
                _pendingLeadingTrivia = SyntaxTriviaList.Empty;
                return token.WithLeadingTrivia(trivia);
            }

            return token;
        }
    }
}
